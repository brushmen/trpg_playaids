<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Storyleaves</title>
    <meta name="description" content="a solo tabletop roleplaying game playaid built with Javascript">
    <meta name="author" content="brushmen">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/common.css">

    <!-- custom CSS -->
    <style>
    body {
        background-color: rgb(220, 217, 205);
        font-family: tahoma, sans-serif;
    }

    select {
        background-color: Gainsboro !important;
    }

    .tooltip > .tooltip-inner{
        background: Gainsboro;
        color: #000;
        max-width: 800px;
        max-height: 700px;
        font-size: 2em;
    }

    #c1, #c2, #c3 {
        position: relative;
    }

    #progress {
        color: green;
    }
    #conditions {
        color: red;
    }

    .active {
        background-color: yellow;
    }
    .focus {
        color: red;
    }

    #table {
        height: 300px;
        overflow: auto;
        border: 1px outset aliceblue;
    }

    #hand {
        height: 100px;
        overflow: auto;
    }

    #deck, #discard {
        font-size: 0.7em;
    }

    #gamelog {
        height: 200px;
        overflow: auto;
        border: 1px solid green;
        font-size: 0.7em;
    }

    #commonArea {
        width: 11.1em;
    }

    #infoArea {
        font-size: 13pt;
        margin: 5px -13px;
        padding-left: 3px;
        height: 230px;
        overflow: auto;
    }

    #notesArea {
        margin: 5px -13px;
        padding-left: 3px;
    }
    #notes {
        height: 400px;
    }

    #deckbox {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
        font-size: 1em;
        min-width: 800px;
        max-width: 1200px;
    }
    #deckboxtext {
        height: 400px;
    }

    #gameArea .card {
        text-align: center;
        display: inline-block;
        width: 6em;
        margin: 0.5em;
        border: 1px solid black;
        font-size: 0.6em;
    }
    #gameArea .card:active {
        background-color: yellow;
    }
    </style>
</head>

<body>
    <!-- hovering panels -->
    <div id="loadbox" style="display: none" class="card shadow">
        <h5 class="card-header">load JSON content</h5>
        <div class="topRightClick" onclick="$('#loadbox').hide();">hide</div>
        <textarea id="loadboxjson" placeholder="JSON only"></textarea>
        <button type="submit" class="btn btn-sm btn-warning">load</button>
    </div>
    <div id="deckbox" style="display: none" class="card shadow">
        <h5 class="card-header">custom deck</h5>
        <div class="topRightClick" onclick="$('#deckbox').hide();">hide</div>
        <div class="card-body">
            <div class="row">
                <div class="col-5">
                    character: person 1<br>
                    character: person 2<br>
                    place: location<br>
                    event: event 1<br>
                    event: event 2<br>
                    item: thing 1<br>
                    item: thing 2<br>
                    item: thing 3<br>
                    aspect: aspect<br>
                    detail: detail
                </div>
                <div class="col-7">
                    <textarea id="deckboxtext" class="form-control form-control-sm" placeholder="paste in list of cards, see left-side formatting example"></textarea>
                    <button type="submit" class="form-control btn btn-sm btn-warning btn-block">load</button>
                </div>
            </div>
        </div>
    </div>
    <div id="imageviewbox" style="display: none" class="card shadow">
        <h6 id="imageviewboxHeader" class="card-header move">image view</h6>
        <div class="topRightClick" onclick="$('#imageviewbox').hide();">hide</div>
        <img src="https://raw.githubusercontent.com/brushmen/trpgplayaid_server/master/public/images/storyleavesflowchart.jpg" id="imageviewImage" alt="an image" title="an image to show the group" />
        <div class="container-fluid input-group p-0">
            <input type="text" id="imageviewImageURL" class="form-control form-control-sm" placeholder="URL of image" />
            <button class="btn btn-sm btn-info" onclick="loadImage('imageviewImage', 'imageviewImageURL');">load image</button>
        </div>
    </div>

    <!-- right side menu buttons, leave space in between for TogetherJS bar. add/remove buttons as applicable -->
    <div id="menubuttons" class="btn-group-vertical shadow">
        <button id="togetherjsbutton" class="btn btn-sm btn-outline-dark" onclick="TogetherJS(this); return false;" title="start TogetherJS to collaborate with friends">👥</button>
        <button id="loaddeckbutton" class="btn btn-sm btn-outline-dark" onclick="$('#deckbox').toggle();" title="load a custom list of cards">🂠</button>
        <button id="loadjsonbutton" class="btn btn-sm btn-outline-dark" onclick="loadJSON(); return false;" title="load a JSON file of the game content">📂</button>
        <button id="savejsonbutton" class="btn btn-sm btn-outline-dark" onclick="saveJSON(); return false;" title="save current game content to a JSON file to download">💾</button>
        <button id="imagebutton" class="btn btn-sm btn-outline-dark" onclick="$('#imageviewbox').toggle(); return false;" title="show an image of character or object">🖼</button>

    </div>
    <button id="clearfieldsbutton" class="btn btn-sm btn-outline-dark shadow" onclick="newGame(); return false;" title="clear fields, start over">🗑</button>

    <!-- main content -->
    <div class="container-fluid">

        <div id="gameArea">
            <div class="row full-height">
                <div class="col justify-content-center align-self-center">
                    <div class="row">

                        <div id="c1" class="col-2 full-height">
                            <div class="row">
                                <div class="col">
                                    <div id="deck" style="border: 1px dashed black; padding: 5px" class="text-center" onclick="setFocus('deck')">deck (100)</div>
                                </div>
                                <div class="col">
                                    <div id="discard" style="border: 1px dashed black; padding: 5px" class="text-center text-muted">discarded</div>
                                </div>
                            </div>
                            <div class="btn-group-vertical" style="width: 100%; margin-top: 10px">
                                <button id="protagonist" class="btn btn-sm btn-outline-dark" onclick="setFocus('protagonist')"><span class="text-primary">protagonist</span></button>
                                <button id="beloved" class="btn btn-sm btn-outline-dark" onclick="setFocus('beloved')"><span class="text-primary">beloved</span></button>
                                <button id="antagonist" class="btn btn-sm btn-outline-dark" onclick="setFocus('antagonist')"><span class="text-primary">antagonist</span></button>
                            </div>
                            <button id="finishsetup" class="btn btn-sm btn-success" style="margin-top: 10px; display: none" onclick="play()">Finish Setup, Start Playing</button>
                            <div class="btn-group-vertical">
                                <button id="gameover" class="btn btn-sm btn-warning" style="display: none" onclick="window.location.reload()">Game Over, Restart</button>
                                <button id="waitandsee" class="btn btn-sm btn-primary" style="display: none" onclick="waitAndSee()">Wait And See</button>
                                <button id="pursuegoal" class="btn btn-sm btn-primary" style="display: none" onclick="pursueGoal()">Pursue Goal</button>
                                <button id="playfromdeck" class="btn btn-sm btn-primary" style="display: none" onclick="playFromDeck()">Play From Deck</button>
                                <button id="sacrificeresource" class="btn btn-sm btn-primary" style="display: none" onclick="sacrificeResource()">Sacrifice Resource</button>
                                <button id="reversecondition" class="btn btn-sm btn-primary" style="display: none" onclick="reverseCondition()">Reverse Condition</button>
                                <button id="attackantagonist" class="btn btn-sm btn-primary" style="display: none" onclick="attackAntagonist()">Attack Antagonist</button>
                                <button id="givein" class="btn btn-sm btn-primary" style="display: none" onclick="giveIn()">Give In</button>
                            </div>
                        </div>

                        <div id="c2" class="col-7 full-height">
                            <div class="row">
                                <div class="btn-group">
                                    <button id="pfacet" class="btn btn-sm btn-outline-dark" onclick="setFocus('pfacet')"><span class="text-primary">protagonist facet</span></button>
                                    <button id="bfacet" class="btn btn-sm btn-outline-dark" onclick="setFocus('bfacet')"><span class="text-primary">beloved facet</span></button>
                                    <button id="pbshared" class="btn btn-sm btn-outline-dark" onclick="setFocus('pbshared')"><span class="text-primary">shared between P/B</span></button>
                                    <button id="afacet" class="btn btn-sm btn-outline-dark" onclick="setFocus('afacet')"><span class="text-primary">antagonist facet</span></button>
                                    <button id="apshared" class="btn btn-sm btn-outline-dark" onclick="setFocus('apshared')"><span class="text-primary">shared between A/P</span></button>
                                    <button id="abshared" class="btn btn-sm btn-outline-dark" onclick="setFocus('abshared')"><span class="text-primary">shared between A/B</span></button>
                                </div>
                            </div>
                            <div id="table" class="row"></div>
                            <div id="hand" class="row"></div>
                            <div id="gamelog" class="row text-muted"></div>
                        </div>

                        <div id="c3" class="col-3 full-height">
                            <div id="commonArea">
                                <div class="row">
                                    <select id="infolist" name="infolist" class="form-control form-control-sm">
                                        <option value="" disabled="disabled" selected="selected">Storyleaves</option>
                                        <option value="brainstorm">brainstorm</option>
                                        <option value="setup">setup</option>
                                        <option value="aturnofgame">a turn of game</option>
                                        <option value="conditions">conditions</option>
                                        <option value="endingagame">ending a game</option>
                                        <option value="" disabled="disabled">appendices</option>
                                        <option value="donot">what not to do</option>
                                        <option value="levelsofvictory">levels of victory</option>
                                        <option value="additionalchapters">additional chapters</option>
                                    </select>
                                </div>

                                <div id="infoArea">
                                    <p>A way to make a little story, about the size of a story-poem, or a fairy tale, or the summary of a TV episode ... in an hour or so. It might have a sad ending ... it might have a happy ending ... you won’t know until you play.</p>
                                    <p><a href="http://gamedevblog.typepad.com/Storyleaves.pdf" target="new">Storyleaves</a> is by Jamie Fristrom.</p>
                                </div>
                                <div id="notesArea">
                                    <textarea id="notes" class="form-control form-control-sm" placeholder="premise, goals, story"></textarea>
                                </div>

                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Bootstrap template script includes -->
    <script src="js/jquery-3.4.1.min.js"></script>
    <script src="js/popper.min.js"></script>
    <script src="js/bootstrap.min.js"></script>

    <script src="js/common.js"></script>

    <!-- TogetherJS config and library -->
    <script>
    TogetherJSConfig_autoStart  = false;
    TogetherJSConfig_siteName = "Storyleaves";
    TogetherJSConfig_dontShowClicks = true;
    TogetherJSConfig_suppressJoinConfirmation = true;
    TogetherJSConfig_suppressInvite = true;
    //use this in single-page apps where being at the same base URL
    //doesn’t mean the two people are looking at the same thing.
    TogetherJSConfig_includeHashInUrl = true;
    TogetherJSConfig_disableWebRTC = true;
    </script>
    <script src="https://togetherjs.com/togetherjs-min.js"></script>

    <!-- other Javascript code -->
    <script>
        var gamehandle = 'storyleaves';
        var gamedata = {};
        var infotext = {
            'brainstorm':
                '<p>Consider the setting and genre you are interesting in. Brainstorm, come up with ideas for Characters, Places, Events, Items, Aspects and Details that fit the setting and genre that you are imagining. It’s best to break down the specific ideas into parts and put them on separate cards.</p><p>Make piles of the different types. The Character stack should be about twice as high as the other stacks.</p><p>Details can be particularly fun: they help define the mood of the story. They could be a sensory motif (blood, moonlight, neon, a cross, a fan, clouds, sunlight, wood smoke, dandelions on the wind); a cinematic look (sweeping vista, murky lighting, close-up shot, slow motion); even mood music. A lot of dark details will weave a dark fictive dream; light and bright colors detail a bright happy-to-be-here place. Sometimes it’s hard to tell what’s a Detail and what’s an Aspect - they’re both often adjectives. It doesn’t really matter, but consider aspects to be plot-affecting (he’s strong, and he might use that strength to achieve something) whereas details would be more for color (he’s silver, and that’s cool, but it’s not going to have repercussions.)</p><p>Each card will essentially be randomly numbered.</p>',
            'setup':
                '<p>Deal cards from the shuffled deck until there are five Character cards on the table. Choose one to be the Protagonist (click on Protagonist, then a Character card), another to be the Beloved (click on Beloved, then a Character card), and another to be the Antagonist (click on Antagonist, then a Character card). Beloved doesn’t necessarily mean beloved in the eros sense - it just means that there is an important relationship between the Protagonist and the Beloved; the Protagonist cares about the Beloved. Could be family, friend, mentor, or something else.</p><p>The Protagonist has three resources: the Protagonist’s character Facet, the Beloved’s character Facet, and something the Protagonist and the Beloved share. Choose a card for each from the ones on the table (click on Protagonist Facet, then click on a card in the center, and so on).</p><p>The Antagonist has three resources: the Antagonist’s character Facet; something the Antagonist and Protagonist share; and something the Antagonist and Beloved share. Choose a card for each.</p><p>Then decide what the cards mean.</p><p>If a character has another character for a facet: this could mean the first character has multiple roles (a fighter and a wizard), or it could mean the second (minor) character is important to the first character somehow - family, lover, secret desire, good friend, boss, sidekick.</p><p>If a character is shared - this is an indirect relationship. The related main characters do not necessarily know each other, but they both have important relationships to the new minor character.</p><p>Adding an aspect to a character means that’s an aspect of the character. Adding an aspect to a relationship means it’s an aspect they both share, and therefore could be a bond between them.</p><p>Adding an event to a character means it’s a defining event in their life. Adding an event to a relationship means it’s a defining event of the relationship - possibly how they met, or possibly something that is now stressing the relationship.</p><p>Adding a place to a character means it’s a place that’s uniquely theirs. Possibly their home or a place they get away to. Adding a place to a relationship means it’s a place important to the relationship - where they met, a place they regularly hang out at, etc.</p><p>Adding an item to a character means it’s their item, or an item they’re looking for. Adding an item to a relationship means it could be an item they share, or an item one has and the other wants, or an item they both want.</p><p>Adding a detail to a character means it’s that character’s description. Adding a detail to a relationship means it somehow describes the relationship. When this character comes into the scene, or this relationship is mentioned, we’ll probably see the detail as a recurring motif or memory hook.</p><p>Give everyone a name.</p><p>Write the first paragraph of the story explaining the situation.</p><p>Come up with a goal for the protagonist that involves the other characters and their facets. Then come up with a goal for the antagonist that obstructs the protagonist.</p><p>Deal five cards, which will form the initial hand, and represent one\'s hold over destiny.</p>',
            'aturnofgame':
                '<p>Play the protagonist, and each turn, you can:<ul><li>pursue my goal</li><li>attack the antagonist</li><li>wait and see what happens</li><li>protect my beloved</li><li>sacrifice a resource</li><li>try to reverse a condition</li></ul></p><p>No matter what the protagonist does (even inaction), the antagonist will try to thwart them. Draw a card representing the antagonist’s efforts. If it’s lower than the card just drawn (or if none was played) the antagonist succeeds in thwarting and antagonizing the protagonist. Write how, using the contents of the card for color.</p><p>Then you can:<ul><li>play a card from your hand in response</li><li>sacrifice a resource with a lower number</li><li>play the top card from the deck, unseen. If it’s higher, take a condition. Either the protagonist is Lost, the beloved is Lost, or they are Estranged from each other.</li><li>give in - take a condition voluntarily. In this case, you get to draw a card for your hand.</li></ul></p><p>And then it’s the next turn.</p><h6>Pursue Goal</h6><p>Play a card from your hand, and write a sentence (or two) about how the protagonist get closer to their goal and how what was on the card related to that. Leave it open-ended, because the antagonist might find a way to prevent them from getting closer to the goal.</p><p><strong>When pursuing goal, lower cards win.</strong></p><p>Achieving a goal requires three successful pursuit attempts. But the protagonist can be set back by a condition.</p><h6>Attacking the Antagonist</h6><p>Choose a resource of the antagonist to destroy. Play a card from your hand - it must be lower than the antagonist resource you are attacking.</p><p>If succesful, the antagonist loses that resource. Write how that diminishes the antagonist.</p><p>If the resource is unique (ie. if it’s <em>the</em> gryphon, not <em>a</em> gryphon), remove the resource card entirely (not to be returned to the deck) so that it will never appear in the saga again, even in a subsequent chapter.</p><p>Destroying the antagonist does not mean the protagonist wins. The goal is what is truly important. But it does mean 2 free cards (the antagonist\'s remaining resources) for your hand.</p><p><strong>When attacking the antagonist, higher cards win.</strong></p><h6>Waiting to see what happens</h6><p>Protagonist does nothing while you get to draw a card. Don’t need to write anything, then go straight to the antagonist move.</p><p><strong>When waiting-and-seeing, higher cards win.</strong></p><h6>Sacrificing a resource</h6><p>Discard one of the protagonist\'s resources (removed from the game, not to be used again even in a subsequent chapter). Write how that resource is lost forever, then draw 3 cards.</p><p>The antagonist responds as normal. If you lose against the antagonist, the protagonist gets a condition, as normal.</p><p><strong>When sacrificing a resource, lower cards win.</strong></p><h6>Trying to reverse a condition</h6><p>A condition can be reversed just like pursuing a goal.</p><p>If the antagonist stops the protagonist, the condition is not reversed, and the protagonist gets another condition.</p><p><strong>When reversing a condition, lower cards win.</strong></p><h6>The Antagonist’s Response</h6><p>No matter what you do, the antagonist responds (even if they’ve been destroyed - this represents the forces of opposition in general). Draw a card from the deck and play it face up in the discard pile.</p><p>If it’s lower than your card, the antagonist takes the advantage and blocks your card. Write how they used the card element to stop the protagonist.</p><p>If it’s higher than your card, the antagonist is defeated - whatever the protagonist tried to do worked. Write how the protagonist succeeded, using the card element as color. Then it’s the next turn.</p><p>If the antagonist is not defeated and has the advantage, there are four things you can do:</p><h6>Answer: better card from my hand</h6><p>If you have a lower card in your hand, play it and write how that element turns the tide back to my favor. It’s now the antagonist’s turn again, and then my turn, and this can go on until I run out of cards and have to do something drastic.</p><h6>Answer: sacrifice a resource with a better number</h6><p>If there is a protagonist resource/facet you are willing to give up, play it and write how that resource is destroyed forever but turns the tide back in my favor. It is removed from the game, never to appear in the story again, not even in a subsequent chapter.</p><h6>Answer: take a risk</h6><p>Play the top card from the deck, unseen.</p><p>If it’s higher than the antagonist’s, then the protagonist loses and takes a condition. Either the protagonist is Lost, the beloved is Lost, or they are Estranged. If it’s lower than the antagonist’s, then the antagonist gets to draw again - if their card is higher than yours you win; if it’s lower then you have to answer again. This can go on multiple times until one side loses.</p><h6>Answer: give in - take a condition voluntarily</h6><p>Draw a card for your hand. Write the condition, maybe show how the protagonist decided discretion was the better part of valor.</p>',
            'conditions':
                '<p>A protagonist can only take each condition once, even if they are reversed. Once they have taken all three the game is over, even if some were reversed.</p><p><strong>Estranged</strong>: Something has come between the protagonist and their beloved. Maybe they are angry with each other, maybe they’re separated geographically or physically.</p><p><strong>Protagonist Lost</strong>: This could mean lost geographically, lost mentally, presumed dead, or otherwise missing. Nobody who cares about the protagonist knows where they are, including the beloved.</p><p><strong>Beloved Lost</strong>: This could mean lost geographically, lost mentally, presumed dead, or otherwise missing. Nobody who cares about them knows where they are, including the protagonist.</p><p>If a condition hasn’t been reversed before the end of the game, it’s permanent.</p>',
            'endingagame':
                '<p>The game ends when:</p><p>The protagonist has made three steps of progress. If Lost conditions still exist at this point, they’re Lost forever. So this is a happy ending or a happy-ending-but-a-price-was-paid. Or:</p><p>Protagonist takes the third condition, <em>even if you have reversed the other two</em>. This is the tragic ending or the lesson-was-learned-but-the-damage-is-irreversible.</p><p>Resignation, if you recognize that striving can only make things worse from here on out, and accept things as they currently stand, that the protagonist will never achieve their goal.</p><p>Once it’s over, you may want to use the last cards in your hand to inspire a sentence or two of epilogue. Maybe they mitigate a tragic ending.</p>',
            'donot':
                '<ul><li>Don’t write stuff that doesn’t make sense just to use a specific card. If you cannot make a card fit, you cannot play it.</li><li>When drawing for the antagonist, even if it doesn’t make sense for the story, the antagonist still wins somehow. In that case, ignore the color on the card and write whatever comes to mind.</li><li>Don’t kill the antagonist until their third resource is destroyed.</li><li>Don’t kill the protagonist or beloved unless they’re Lost, and make it a “presumed dead” sort of kill, something reversible, until they’re Lost Forever.</li></ul>',
            'levelsofvictory':
                '<h6>Chinatown</h6><p>The most tragic ending would be to burn some Traits and take all the conditions without reversing them, before achieving the goal and while the antagonist lives on in triumph.</p><h6>The Commitments</h6><p>Slightly less tragic would be to avoid burning Traits or to reverse some of the conditions.</p><h6>Hamlet</h6><p>Or to defeat the antagonist but to also take conditions and not achieve a goal.</p><h6>The Empire Strikes Back</h6><p>A bittersweet ending would be to achieve my goal but to burn some Traits and take a condition on the way there - while the antagonist remains...</p><h6>Sunshine</h6><p>Or maybe I defeat the antagonist, achieve my goal, but lose my self on the way.</p><h6>The Dark Knight</h6><p>Or lose my beloved.</p><h6>Tangled</h6><p>The penultimate victory would be to achieve my goal, defeat the antagonist, without keeping any conditions and burning only one trait.</p><h6>The Incredibles</h6><p>The ultimate victory would be to achieve my goal, defeat theantagonist, without keeping any conditions and burning no traits.</p>',
            'additionalchapters':
                '<p>You probably want to use the same deck again for more stories. Maybe add some more cards to the deck or take some out. Maybe make the story about the same protagonist, but choose a new beloved (though possibly the same beloved comes up in the draw) and a new antagonist. Maybe the story is a prequel. Or maybe it’s just another story in the same world with completely different characters.</p>'
        };

        ////  CARDS FOR THE STORY DECK ///////////
        var default_deck = [
            "character: brother",
            "character: sister",
            "character: father",
            "character: mother",
            "character: grandmother",
            "character: grandfather",
            "character: granddaughter",
            "character: grandson",
            "character: daughter",
            "character: son",
            "character: uncle",
            "character: aunt",
            "character: cousin",
            "character: best friend",
            "character: confidant",
            "character: classmate",
            "character: lover",
            "character: neighbor",
            "character: civilian",
            "character: refugee",
            "character: doctor",
            "character: soldier",
            "character: cook",
            "character: farmer",
            "character: artist",
            "character: writer",
            "character: captain",
            "character: mercenary",
            "character: smuggler",
            "character: laborer",
            "character: guard",
            "character: bodyguard",
            "character: entertainer",
            "character: street performer",
            "character: actor",
            "character: singer",
            "character: danger",
            "character: musician",
            "character: poet",
            "character: trader",
            "character: hunter",
            "character: bounty-hunter",
            "character: scout",
            "character: messenger",
            "character: spy",
            "character: prisoner",
            "character: con-artist",
            "character: detective",
            "character: judge",
            "character: marketer",
            "character: journalist",
            "character: courier",
            "character: warlord",
            "character: diplomat",
            "character: politician",
            "character: scholar",
            "character: law-keeper",
            "character: custodian",
            "character: miner",
            "character: secretary",
            "character: governor",
            "character: inspector",
            "character: assassin",
            "character: subordinate",
            "character: prostitute",
            "place: home",
            "place: jail",
            "place: docks",
            "place: barrack",
            "place: hospital",
            "place: restaurant",
            "place: inn",
            "place: theater",
            "event: birth",
            "event: death",
            "event: marriage",
            "event: injury",
            "event: illness",
            "event: hijack",
            "event: stage show",
            "event: negotiation",
            "event: inauguration",
            "event: natural disaster",
            "event: invention",
            "event: invasion",
            "event: date",
            "event: duel",
            "event: battle",
            "event: ambush",
            "event: sacrifice",
            "event: surgery",
            "event: interrogation",
            "event: explosion",
            "event: competition",
            "event: celebration",
            "event: betrayal",
            "event: robbery",
            "event: trauma",
            "event: earthquake",
            "item: weapon",
            "item: treasure",
            "item: gift",
            "item: drug",
            "item: alcohol",
            "item: painting",
            "item: book",
            "item: map",
            "item: letter",
            "item: mask",
            "item: heirloom",
            "aspect: strong",
            "aspect: fast",
            "aspect: smart",
            "aspect: wise",
            "aspect: nimble",
            "aspect: beautiful",
            "aspect: charming",
            "aspect: loving",
            "aspect: mad",
            "aspect: logical",
            "aspect: cheerful",
            "aspect: stubborn",
            "aspect: inhuman",
            "aspect: loyal",
            "aspect: disabled",
            "aspect: friendless",
            "aspect: paranoid",
            "aspect: greedy",
            "aspect: arrogant",
            "aspect: lascivious",
            "aspect: abrasive",
            "aspect: noisy",
            "aspect: reserved",
            "aspect: detached",
            "aspect: anxious",
            "aspect: depressed",
            "aspect: awkward",
            "aspect: austere",
            "aspect: authoritative",
            "aspect: careless",
            "aspect: bossy",
            "aspect: vindictive",
            "aspect: classy",
            "aspect: clumsy",
            "aspect: combative",
            "aspect: controlling",
            "aspect: cowardly",
            "aspect: ambitious",
            "aspect: ambivalent",
            "aspect: honorable",
            "aspect: honest",
            "aspect: decisive",
            "aspect: extreme",
            "aspect: fierce",
            "aspect: flirty",
            "aspect: forgiving",
            "aspect: glamorous",
            "aspect: gregarious",
            "aspect: guilty",
            "aspect: hateful",
            "aspect: hostile",
            "aspect: humble",
            "aspect: immature",
            "aspect: incompetent",
            "aspect: industrious",
            "aspect: intimidating",
            "aspect: insightful",
            "aspect: intense",
            "aspect: intellectual",
            "aspect: introspective",
            "aspect: jaded",
            "aspect: jittery",
            "aspect: keen",
            "aspect: malicious",
            "aspect: manipulative",
            "aspect: mercurial",
            "aspect: mischievous",
            "aspect: optimistic",
            "aspect: pessimistic",
            "aspect: ostentatious",
            "aspect: quixotic",
            "aspect: scarred",
            "aspect: adopted",
            "aspect: secretive",
            "aspect: underhanded",
            "aspect: shadowy",
            "aspect: shady",
            "aspect: scheming",
            "aspect: ex",
            "aspect: nemesis",
            "aspect: superior",
            "aspect: inferior",
            "aspect: patron",
            "detail: dripping blood",
            "detail: suicide",
            "detail: homocide",
            "detail: artificial limb",
            "detail: medicine"
        ];

        gamedata['cards'] = default_deck;
        var num_of_reshuffle_cards = Math.ceil(gamedata['cards'].length / 18);

        var table = new Array();
        var resources = new Array();
        var discard = new Array();
        var hand = new Array();

        var phase = "setup";
        var roundnumber = 0;
        var focus = "";
        var protagonist = "";
        var beloved = "";
        var antagonist = "";
        var pfacet = "";
        var bfacet = "";
        var pbshared = "";
        var afacet = "";
        var apshared = "";
        var abshared = "";

        var color = "black";
        var goalProgress = 0;
        var goalMax = 3;
        var conditions = 0;
        var conditionMax = 3;
        var protagMove = "";
        var protagCard = "";
        var protagCardValue = 0;
        var antagCard = "";
        var antagCardValue = 0;
        var antagAttacked = false;
        var attackCardPicked = false;
        var targetCardPicked = false;

        // prep element effects
        dragElement(document.getElementById("imageviewbox"));

        newSetup();

        function newSetup() {
            num_of_reshuffle_cards = Math.ceil(gamedata['cards'].length / 18);
            table = new Array();
            resources = new Array();
            discard = new Array();
            hand = new Array();

            phase = "setup";
            roundnumber = 0;
            focus = "";
            protagonist = "";
            beloved = "";
            antagonist = "";
            pfacet = "";
            bfacet = "";
            pbshared = "";
            afacet = "";
            apshared = "";
            abshared = "";

            color = "black";
            goalProgress = 0;
            conditions = 0;
            protagMove = "";
            protagCard = "";
            protagCardValue = 0;
            antagCard = "";
            antagCardValue = 0;
            antagAttacked = false;
            attackCardPicked = false;
            targetCardPicked = false;

            // step 0: prepare the initial deck

            gamedata['cards'] = shuffle(gamedata['cards']);

            // give each card a value
            for (var c = 0; c < gamedata['cards'].length; c++) {
                gamedata['cards'][c] = gamedata['cards'][c] + " (" + (c+1) + ")";
            }

            // reshuffle again to keep things different each time
            gamedata['cards'] = shuffle(gamedata['cards']);

            // step 1: draw from deck until 5 character cards drawn,
            // but make sure at least 6 resources cards are drawn as well

            var num_of_character_cards = 0;
            var num_of_cards = 0;

            for (var i = 0; i < gamedata['cards'].length; i++) {

                var card = gamedata['cards'].shift();
                table.push(card);

                if (card.search("character") == 0) {
                    num_of_character_cards += 1;
                }

                num_of_cards += 1;

                if (num_of_character_cards >= 5 &&
                    num_of_cards >= 16) {
                    break;
                }
            }
        }

        $('[data-toggle="tooltip"]').tooltip({
            html: true,
            placement: 'auto'
        });

        updateTable();

        var x = document.getElementById("gameArea");
        if (x.addEventListener) {
            // For all major browsers, except IE 8 and earlier
            x.addEventListener("click", setupListener);
        } else if (x.attachEvent) {
            // For IE 8 and earlier versions
            x.attachEvent("onclick", setupListener);
        }

        $('#infolist').on('change', function() {
            // only update locally
            var $infolist = $('#infolist');
            var $infoArea = $('#infoArea');
            $infoArea.html(infotext[$infolist.val()]);
        });

        function loadJSON() {
            $('#loadbox').toggle();
        }

        $('#loadbox button[type=submit]').click(function(e) {
            e.preventDefault();
            var json = $('#loadboxjson').val();
            JSONtoGame(JSON.parse(json));
            // hide the loadbox
            $('#loadbox').hide();
            updateGame();
        });

        $('#deckbox button[type=submit]').click(function(e) {
            e.preventDefault();
            var deck = $('#deckboxtext').val();
            inputDeck(deck);
            // hide the loadbox
            $('#deckbox').hide();
            updateGame();
        });

        function saveJSON() {
            var filename = gamehandle + getTodayString() + '.json';
            // generate the file to download locally
            download(filename, GametoJSON());
        }

        function newGame() {
            if(confirm('Clear all fields and start a new game?')) {
                clearFields();
                gamedata['cards'] = default_deck;
                newSetup();
                updateGame();
                updateTable();
            }
        }

        function JSONtoGame(obj) {
            if (obj) {
                gamedata = obj[gamehandle];
            }
        }

        function GametoJSON() {
            gamedata['notes'] = $('#notes').val();
            var gameJSON = {};
            if (gamedata) {
                gameJSON[gamehandle] = gamedata;
                gameJSON = JSON.stringify(gameJSON, null, "\t");
            }
            return gameJSON;
        }

        function updateGame() {
            $('#notes').val(gamedata['notes']);
        }

        function loadImage(imgID, imgURLID) {
            var imgURL = $('#' + imgURLID).val();
            $('#' + imgID).prop('src', imgURL);
            gamedata['currentimage'] = imgURL;
        }

        //////// UI INTERACTION /////////////

        function updateTable() {
            var html = '';

            for (var i = 0; i < table.length; i++) {

                card = table[i];
                if (cardType(card) == "character") {
                    color = "black";
                }
                else if (cardType(card) == "place") {
                    color = "green";
                }
                else if (cardType(card) == "event") {
                    color = "red";
                }
                else if (cardType(card) == "item") {
                    color = "blue";
                }
                else if (cardType(card) == "aspect") {
                    color = "purple";
                }
                else if (cardType(card) == "detail") {
                    color = "orange";
                }

                html += '<div class="card" style="color: ' + color + '" onclick="pickCard(\'' + card + '\')">' + card + '</div>';
            }
            $('#table').html(html);
        }

        function updateDeck() {
            var html = 'deck (' + gamedata['cards'].length + ")";
            $('#deck').html(html);
        }

        function updateHand() {
            var html = 'hand: ';
            for (var i = 0; i < hand.length; i++) {
                html += '<div class="card" onclick="pickCard(\'' + hand[i] + '\')">' + hand[i] + '</div>';
            }
            $('#hand').html(html);
        }

        function updateDiscard() {
            var html = 'discarded';
            var last = discard[discard.length - 1];
            if (last) { // if not empty
                html += "<br>" + last;
            }
            $('#discard').html(html);
        }

        function updateProtagonist() {
            var html = '<span class="text-primary">protagonist</span>';
            if (phase == "setup") {
                if (protagonist) {
                    html += '<div class="card" onclick="pickCard(\'' + protagonist + '\')">' + protagonist + '</div>';
                }
            }
            else if (phase == "play") {
                $('#protagonist').prop('disabled', true);
                html += "<br>" + cardDesc(protagonist);
                html += '<div id="progress">' + goalProgress + '/' + goalMax + 'progress</div><div id="conditions">' + conditions + '/' + conditionMax + ' conditions</div>';
            }
            $('#protagonist').html(html);
        }

        function updateBeloved() {
            var html = '<span class="text-primary">beloved</span>';

            if (phase == "setup") {
                if (beloved) {
                    html += '<div class="card" onclick="pickCard(\'' + beloved + '\')">' + beloved + '</div>';
                }
            }
            else if (phase == "play") {
                $('#beloved').prop('disabled', true);
                if (beloved) {
                    html += "<br>" + cardDesc(beloved);
                }
            }
            $('#beloved').html(html);
        }

        function updateAntagonist() {
            var html = '<span class="text-primary">antagonist</span>';

            if (phase == "setup") {
                if (antagonist) {
                    html += '<div class="card" onclick="pickCard(\'' + antagonist + '\')">' + antagonist + '</div>';
                }
            }
            else if (phase == "play") {
                $('#antagonist').prop('disabled', true);
                html += "<br>" + cardDesc(antagonist);
            }
            $('#antagonist').html(html);
        }

        function updatePFacet() {
            var html = '<span class="text-primary">protagonist facet</span>';
            if (pfacet) {
                html += '<div class="card" onclick="pickCard(\'' + pfacet + '\')">' + pfacet + '</div>';
            }
            $('#pfacet').html(html);
        }

        function updateBFacet() {
            var html = '<span class="text-primary">beloved facet</span>';
            if (bfacet) {
                html += '<div class="card" onclick="pickCard(\'' + bfacet + '\')">' + bfacet + '</div>';
            }
            $('#bfacet').html(html);
        }

        function updatePBShared() {
            var html = '<span class="text-primary">shared between P/B</span>';
            if (pbshared) {
                html += '<div class="card" onclick="pickCard(\'' + pbshared + '\')">' + pbshared + '</div>';
            }
            $('#pbshared').html(html);
        }

        function updateAFacet() {
            var html = '<span class="text-primary">antgonist facet</span>';
            if (afacet) {
                html += '<div class="card" onclick="pickCard(\'' + afacet + '\')">' + afacet + '</div>';
            }
            $('#afacet').html(html);
        }

        function updateAPShared() {
            var html = '<span class="text-primary">shared between A/P</span>';
            if (apshared) {
                html += '<div class="card" onclick="pickCard(\'' + apshared + '\')">' + apshared + '</div>';
            }
            $('#apshared').html(html);
        }

        function updateABShared() {
            var html = '<span class="text-primary">shared between A/B</span>';
            if (abshared) {
                html += '<div class="card" onclick="pickCard(\'' + abshared + '\')">' + abshared + '</div>';
            }
            $('#abshared').html(html);
        }

        function updateHint(text) {
            var old = document.getElementById("gamelog").innerHTML;
            document.getElementById("gamelog").innerHTML = text + "<br>" + old;
        }

        function enablePlayerTurnButtons(show = true) {
            var style = "none";
            if (show) {
                style = "inline";
            }

            document.getElementById("waitandsee").style.display = style;
            document.getElementById("pursuegoal").style.display = style;
            document.getElementById("sacrificeresource").style.display = style;
            if (resources.length < 1) {
                // hide this button if there is no available resource
                document.getElementById("sacrificeresource").style.display = "none";
            }
            document.getElementById("reversecondition").style.display = style;
            if (conditions == 0) {
                document.getElementById("reversecondition").style.display = "none";
            }
            document.getElementById("attackantagonist").style.display = style;
            if (antagAttacked) {
                // hide this button if antagonist was attacked successfully
                document.getElementById("attackantagonist").style.display = "none";
            }
        }

        function enablePlayerResponseButtons(show = true) {
            var style = "none";
            if (show) {
                style = "inline";
            }

            if (hasLowerResource()) {
                document.getElementById("sacrificeresource").style.display = style;
            }
            document.getElementById("playfromdeck").style.display = style;
            document.getElementById("givein").style.display = style;
        }

        //// OTHER FUNCTIONS ///////////////

        function shuffle(array) {
          var currentIndex = array.length, temporaryValue, randomIndex;

          // While there remain elements to shuffle...
          while (0 !== currentIndex) {

            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
          }

          return array;
        }

        function reshuffle() {
            updateHint("note: RESHUFFLE card was drawn, discarded cards will return to the deck");

            // shuffle discard pile back into deck
            gamedata['cards'] = gamedata['cards'].concat(discard);
            discard = new Array();

            // shuffle
            gamedata['cards'] = shuffle(gamedata['cards']);
        }

        function setFocus(variable) {
            var hint_choose_char = "Hint: select or unselect a character for ";

            switch(variable) {
                case "protagonist":
                    focus = variable;
                    if (phase == "setup") {
                        updateHint(hint_choose_char + " " + variable);
                    }
                    break;
                case "beloved":
                    focus = variable;
                    if (phase == "setup") {
                        updateHint(hint_choose_char + " " + variable);
                    }
                    break;
                case "antagonist":
                    focus = variable;
                    if (phase == "setup") {
                        updateHint(hint_choose_char + " " + variable);
                    }
                    break;
                case "pfacet":
                    focus = variable;
                    if (phase == "setup") {
                        updateHint(hint_choose_char + " " + " protagonist's facet");
                    }
                    break;
                case "bfacet":
                    focus = variable;
                    if (phase == "setup") {
                        updateHint(hint_choose_char + " " + " beloved's facet");
                    }
                    break;
                case "pbshared":
                    focus = variable;
                    if (phase == "setup") {
                        updateHint(hint_choose_char + " facet shared between protagonist and beloved");
                    }
                    break;
                case "afacet":
                    focus = variable;
                    if (phase == "setup") {
                        updateHint(hint_choose_char + " antagonist's facet");
                    }
                    break;
                case "apshared":
                    focus = variable;
                    if (phase == "setup") {
                        updateHint(hint_choose_char + " facet shared between antagonist and protagonist");
                    }
                    break;
                case "abshared":
                    focus = variable;
                    if (phase == "setup") {
                        updateHint(hint_choose_char + " facet shared between antagonist and beloved");
                    }
                    break;
                case "deck":
                    focus = variable;
                    if (phase == "setup") {
                        updateDeck();
                    }
                    break;
                case "pursue":
                    focus = variable;
                    break;
                case "sacrifice":
                    focus = variable;
                    break;
                case "attack":
                    focus = variable;
                    break;
                default:
                    break;
            }
        }

        function pickCard(card) {
            var hint_characterplease = "Hint: pick a character type card please";
            var hint_pickfreecard = "Hint: pick a card that's not already associated please";

            if (phase == "setup") {

                if (focus == "protagonist") {

                    // make sure card is of character type

                    if (cardType(card) == "character") {

                        if (protagonist == card) {
                            // unselecting the character card
                            moveCard(card, focus, "table");
                        }

                        else {
                            // choose from cards on the table
                            if (table.includes(card)) {
                                if (protagonist == "") {
                                    moveCard(card, "table", focus);
                                }
                                else { // replace existing choice
                                    moveCard(protagonist, focus, "table");
                                    moveCard(card, "table", focus);
                                }
                            }
                            else {
                                updateHint(hint_pickfreecard);
                            }
                        }

                    }

                    else {
                        updateHint(hint_characterplease);
                    }
                }

                else if (focus == "beloved") {

                    // make sure card is of character type
                    if (cardType(card) == "character") {

                        if (beloved == card) {
                            // unselecting the character card
                            moveCard(card, focus, "table");
                        }

                        else {
                            // choose from cards on the table
                            if (table.includes(card)) {
                                if (beloved == "") {
                                    moveCard(card, "table", focus);
                                }
                                else { // replace existing choice
                                    moveCard(beloved, focus, "table");
                                    moveCard(card, "table", focus);
                                }
                            }
                            else {
                                updateHint(hint_pickfreecard);
                            }
                        }
                    }
                    else {
                        updateHint(hint_characterplease);
                    }
                }

                else if (focus == "antagonist") {
                    // make sure card is of character type

                    if (cardType(card) == "character") {

                        if (antagonist == card) {
                            // unselecting the character card
                            moveCard(card, focus, "table");
                        }

                        else {
                            // choose from cards on the table
                            if (table.includes(card)) {
                                if (antagonist == "") {
                                    moveCard(card, "table", focus);
                                }
                                else { // replace existing choice
                                    moveCard(antagonist, focus, "table");
                                    moveCard(card, "table", focus);
                                }
                            }
                            else {
                                updateHint(hint_pickfreecard);
                            }
                        }
                    }
                    else {
                        updateHint(hint_characterplease);
                    }
                }

                else if (focus == "pfacet") {

                    if (pfacet == card) {
                        // unselecting the card
                        moveCard(card, focus, "table");
                    }
                    else {
                        // choose from cards on the table
                        if (table.includes(card)) {
                            if (pfacet == "") {
                                moveCard(card, "table", focus);
                            }
                            else { // replace existing choice
                                moveCard(pfacet, focus, "table");
                                moveCard(card, "table", focus);
                            }
                        }
                        else {
                            updateHint(hint_pickfreecard);
                        }
                    }
                }

                else if (focus == "bfacet") {
                    if (bfacet == card) {
                        // unselecting the card
                        moveCard(card, focus, "table");
                    }
                    else {
                        // choose from cards on the table
                        if (table.includes(card)) {
                            if (bfacet == "") {
                                moveCard(card, "table", focus);
                            }
                            else { // replace existing choice
                                moveCard(bfacet, focus, "table");
                                moveCard(card, "table", focus);
                            }
                        }
                        else {
                            updateHint(hint_pickfreecard);
                        }
                    }
                }

                else if (focus == "pbshared") {

                    if (pbshared == card) {
                        // unselecting the card
                        moveCard(card, focus, "table");
                    }
                    else {
                        // choose from cards on the table
                        if (table.includes(card)) {
                            if (pbshared == "") {
                                moveCard(card, "table", focus);
                            }
                            else { // replace existing choice
                                moveCard(pbshared, focus, "table");
                                moveCard(card, "table", focus);
                            }
                        }
                        else {
                            updateHint(hint_pickfreecard);
                        }
                    }
                }

                else if (focus == "afacet") {

                    if (afacet == card) {
                        // unselecting the card
                        moveCard(card, focus, "table");
                    }
                    else {
                        // choose from cards on the table
                        if (table.includes(card)) {
                            if (afacet == "") {
                                moveCard(card, "table", focus);
                            }
                            else { // replace existing choice
                                moveCard(afacet, focus, "table");
                                moveCard(card, "table", focus);
                            }
                        }
                        else {
                            updateHint(hint_pickfreecard);
                        }
                    }
                }

                else if (focus == "apshared") {

                    if (apshared == card) {
                        // unselecting the card
                        moveCard(card, focus, "table");
                    }
                    else {
                        // choose from cards on the table
                        if (table.includes(card)) {
                            if (apshared == "") {
                                moveCard(card, "table", focus);
                            }
                            else { // replace existing choice
                                moveCard(apshared, focus, "table");
                                moveCard(card, "table", focus);
                            }
                        }
                        else {
                            updateHint(hint_pickfreecard);
                        }
                    }
                }

                else if (focus == "abshared") {

                    if (abshared == card) {
                        // unselecting the card
                        moveCard(card, focus, "table");
                    }
                    else {
                        // choose from cards on the table
                        if (table.includes(card)) {
                            if (abshared == "") {
                                moveCard(card, "table", focus);
                            }
                            else { // replace existing choice
                                moveCard(abshared, focus, "table");
                                moveCard(card, "table", focus);
                            }
                        }
                        else {
                            updateHint(hint_pickfreecard);
                        }
                    }
                }
            }
            else if (phase == "play") {

                if (protagMove == "wait" && focus != "sacrifice") {

                    // card should be from player's hand
                    if (hand.includes(card)) {
                        if (protagCard == "") {
                            moveCard(card, "hand", "table");
                            protagCard = card;
                            protagCardValue = cardValue(card);
                        }

                        // higher card wins
                        if (protagCardValue > antagCardValue) {
                            updateHint("{after wait-and-see} your " + protagCard + " beats " + antagCard + "; round " + roundnumber + " ends");
                            newRound();
                        }
                        else {
                            updateHint("{after wait-and-see} your " + protagCard + " does not beat " + antagCard + ", how do you respond?");
                            responseTurnSetup();
                            protagCard = "";
                        }
                    }
                    else {
                        updateHint("Hint: play cards from your hand or try another option");
                    }
                }

                else if (protagMove == "pursue" && focus != "sacrifice") {
                    // card should be from player's hand
                    if (hand.includes(card)) {
                        if (protagCard == "") {
                            moveCard(card, "hand", "table");
                            protagCard = card;
                            protagCardValue = cardValue(card);
                        }

                        if (antagCard == "") {
                            antagMove();
                        }

                        // lower card wins
                        if (protagCardValue < antagCardValue) {
                            goalProgress++;
                            updateProtagonist();
                            updateHint("{pursue goal} " + protagCard + " beats " + antagCard + "; you gain progress; round " + roundnumber + " ends");
                            newRound();
                        }
                        else { // player may respond
                            responseTurnSetup();
                            updateHint("{pursue goal} your " + protagCard + " does not beat " + antagCard + ", how do you respond?");
                            protagCard = "";
                        }
                    }
                }

                else if (protagMove == "reverse" && focus != "sacrifice") {
                    // card should be from player's hand
                    if (hand.includes(card)) {
                        if (protagCard == "") {
                            moveCard(card, "hand", "table");
                            protagCard = card;
                            protagCardValue = cardValue(card);
                        }

                        if (antagCard == "") {
                            antagMove();
                        }

                        // lower card wins
                        if (protagCardValue < antagCardValue) {
                            updateHint("{reverse condition} your " + protagCard + " beats " + antagCard + "; reverse one existing condition narratively but not mechanically; round " + roundnumber + " ends");
                            newRound();
                        }
                        else { // player may respond
                            responseTurnSetup();
                            updateHint("{reverse condition} your " + protagCard + " does not beat " + antagCard + ", how do you respond?");
                            protagCard = "";
                        }
                    }
                }

                else if (protagMove == "sacrifice" && focus == "sacrifice") {
                    // during sacrifice

                    // pick a card from available resources
                    var index = resources.indexOf(card);
                    if (index > -1) {
                        resources.splice(index, 1);
                        if (card == pfacet) {
                            pfacet = "";
                            updatePFacet();
                        }
                        else if (card == bfacet) {
                            bfacet = "";
                            updateBFacet();
                        }
                        else if (card == pbshared) {
                            pbshared = "";
                            updatePBShared();
                        }
                        else if (card == afacet) {
                            afacet = "";
                            updateAFacet();
                        }
                        else if (card == apshared) {
                            apshared = "";
                            updateAPShared();
                        }
                        else if (card == abshared) {
                            abshared = "";
                            updateABShared();
                        }
                        // draw 3 cards from deck
                        for (var i = 0; i < 3; i++) {
                            moveCard("", "deck", "hand");
                        }
                        updateHint("{sacrifice} remove " + card + "; draw 3 cards into hand; now lower card wins");
                        protagCard = card;
                        protagCardValue = cardValue(protagCard);

                        if (antagCard == "") {
                            antagMove();
                        }
                        // lower card wins
                        if (protagCardValue < antagCardValue) {
                            updateHint("{after sacrifice} your " + protagCard + " beats " + antagCard + "; round " + roundnumber + " ends");
                            newRound();
                        }
                        else {
                            updateHint("{after sacrifice} your " + protagCard + " does not beat " + antagCard + ", how do you respond?");
                            responseTurnSetup();
                        }

                    }
                    else {
                        updateHint("Hint: this is not available to you to be sacrificed");
                    }

                }
                else if (protagMove == "sacrifice") {
                    // after sacrifice

                    // card should be the one sacrificed

                    // lower card wins
                    if (protagCardValue < antagCardValue) {
                        updateHint("{after sacrifice} your " + protagCard + " beats " + antagCard + "; round " + roundnumber + " ends");
                        newRound();
                    }
                    else {
                        updateHint("{after sacrifice} your " + protagCard + " does not beat " + antagCard + ", how do you respond?");
                        responseTurnSetup();

                        if (hand.includes(card)) {
                            moveCard(card, "hand", "table");
                            protagCard = card;
                            protagCardValue = cardValue(card);

                            if (protagCardValue < antagCardValue) {
                                updateHint("{after sacrifice} your " + protagCard + " beats " + antagCard + "; antagonist responds");

                                antagMove();

                                if (protagCardValue < antagCardValue) {
                                    updateHint("{after sacrifice} your " + protagCard + " beats " + antagCard + "; round " + roundnumber + " ends");

                                    newRound();
                                }
                                else {
                                    updateHint("{after sacrifice} your " + protagCard + " does not beat " + antagCard + ", how do you respond?");
                                    responseTurnSetup();
                                }
                            }
                            else {
                                updateHint("{after sacrifice} your " + protagCard + " does not beat " + antagCard + ", how do you respond?");
                                responseTurnSetup();
                            }
                        }
                    }
                }

                else if (protagMove == "attack") {
                    // pick a card from hand

                    if (hand.includes(card) && !attackCardPicked) {
                        moveCard(card, "hand", "table");
                        protagCard = card;
                        protagCardValue = cardValue(card);
                        attackCardPicked = true;
                        updateHint("Hint: pick antagonist's resource to target; higher card wins");
                    }
                    if ((card == afacet || card == apshared ||
                        card == abshared) && !targetCardPicked) {
                        antagCard = card;
                        antagCardValue = cardValue(card);
                        targetCardPicked = true;
                        updateHint("Hint: pick a card from your hand; higher card wins");
                    }

                    if (attackCardPicked && targetCardPicked) {

                        // higher card wins
                        if (protagCardValue > antagCardValue) {
                            // remove the targeted resource card,
                            // from play, and the other 2 resources
                            // becomes usable by the player
                            if (afacet == antagCard) {
                                afacet = "";
                                updateAFacet();
                                resources.push(apshared);
                                resources.push(abshared);
                            }
                            else if (apshared == antagCard) {
                                apshared = "";
                                updateAPShared();
                                resources.push(afacet);
                                resources.push(abshared);
                            }
                            else if (abshared == antagCard) {
                                abshared = "";
                                updateABShared();
                                resources.push(afacet);
                                resources.push(apshared);
                            }
                            attackCardPicked = false;
                            targetCardPicked = false;
                            antagAttacked = true;
                            updateHint("{attack antagonist} your " + protagCard + " beats " + antagCard + "; you gain antagonist's remaining 2 resources; round " + roundnumber + " ends");
                            newRound();
                        }
                        else {
                            attackCardPicked = false;
                            targetCardPicked = false;
                            responseTurnSetup();
                            updateHint("{attack antagonist} your " + protagCard + " does not beat " + antagCard + ", how do you respond?");
                            antagCard = "";
                        }
                    }
                }
            }

            // after clicking, clear focus
            focus = "";
        }

        function moveCard(card, from, to) {
            var index = 0;

            if (phase == "setup") {
                if (from == "table" && to == "protagonist") {
                    index = table.indexOf(card);
                    if (index > -1) {
                        table.splice(index, 1);
                        protagonist = card;
                        updateTable();
                        updateProtagonist();
                    }
                }

                else if (from == "protagonist" && to == "table") {
                    if (protagonist == card) {
                        protagonist = "";
                        table.push(card);
                        updateTable();
                        updateProtagonist();
                    }
                }

                else if (from == "table" && to == "beloved") {
                    index = table.indexOf(card);
                    if (index > -1) {
                        table.splice(index, 1);
                        beloved = card;
                        updateTable();
                        updateBeloved();
                    }
                }

                else if (from == "beloved" && to == "table") {
                    if (beloved == card) {
                        beloved = "";
                        table.push(card);
                        updateTable();
                        updateBeloved();
                    }
                }

                else if (from == "table" && to == "antagonist") {
                    index = table.indexOf(card);
                    if (index > -1) {
                        table.splice(index, 1);
                        antagonist = card;
                        updateTable();
                        updateAntagonist();
                    }
                }

                else if (from == "antagonist" && to == "table") {
                    if (antagonist == card) {
                        antagonist = "";
                        table.push(card);
                        updateTable();
                        updateAntagonist();
                    }
                }

                else if (from == "table" && to == "pfacet") {
                    index = table.indexOf(card);
                    if (index > -1) {
                        table.splice(index, 1);
                        pfacet = card;
                        updateTable();
                        updatePFacet();
                    }
                }

                else if (from == "pfacet" && to == "table") {
                    if (pfacet == card) {
                        pfacet = "";
                        table.push(card);
                        updateTable();
                        updatePFacet();
                    }
                }

                else if (from == "table" && to == "bfacet") {
                    index = table.indexOf(card);
                    if (index > -1) {
                        table.splice(index, 1);
                        bfacet = card;
                        updateTable();
                        updateBFacet();
                    }
                }

                else if (from == "bfacet" && to == "table") {
                    if (bfacet == card) {
                        bfacet = "";
                        table.push(card);
                        updateTable();
                        updateBFacet();
                    }
                }

                else if (from == "table" && to == "pbshared") {
                    index = table.indexOf(card);
                    if (index > -1) {
                        table.splice(index, 1);
                        pbshared = card;
                        updateTable();
                        updatePBShared();
                    }
                }

                else if (from == "pbshared" && to == "table") {
                    if (pbshared == card) {
                        pbshared = "";
                        table.push(card);
                        updateTable();
                        updatePBShared();
                    }
                }

                else if (from == "table" && to == "afacet") {
                    index = table.indexOf(card);
                    if (index > -1) {
                        table.splice(index, 1);
                        afacet = card;
                        updateTable();
                        updateAFacet();
                    }
                }

                else if (from == "afacet" && to == "table") {
                    if (afacet == card) {
                        afacet = "";
                        table.push(card);
                        updateTable();
                        updateAFacet();
                    }
                }

                else if (from == "table" && to == "apshared") {
                    index = table.indexOf(card);
                    if (index > -1) {
                        table.splice(index, 1);
                        apshared = card;
                        updateTable();
                        updateAPShared();
                    }
                }

                else if (from == "apshared" && to == "table") {
                    if (apshared == card) {
                        apshared = "";
                        table.push(card);
                        updateTable();
                        updateAPShared();
                    }
                }

                else if (from == "table" && to == "abshared") {
                    index = table.indexOf(card);
                    if (index > -1) {
                        table.splice(index, 1);
                        abshared = card;
                        updateTable();
                        updateABShared();
                    }
                }

                else if (from == "abshared" && to == "table") {
                    if (abshared == card) {
                        abshared = "";
                        table.push(card);
                        updateTable();
                        updateABShared();
                    }
                }
            }
            else if (phase == "play") {

                if (from == "deck" && to == "hand") {

                    if (gamedata['cards'].length > 0) {

                        while(true) { // loop until a valid card drawn

                            if (gamedata['cards'][0] == "RESHUFFLE") {
                                reshuffle();
                            }
                            else { // only add to hand if not a reshuffle card
                                card = gamedata['cards'].shift();
                                hand.push(card);
                                break;
                            }
                        }
                    }
                    // update cards display
                    updateHand();
                }

                else if (from == "deck" && to == "discard") {
                    if (gamedata['cards'].length > 0) {

                        while(true) { // loop until a valid card drawn

                            if (gamedata['cards'][0] == "RESHUFFLE") {
                                reshuffle();
                            }
                            else { // only add to hand if not a reshuffle card
                                card = gamedata['cards'].shift();
                                discard.push(card);
                                break;
                            }
                        }
                    }
                    // update cards display
                    updateDiscard();
                }

                else if (from == "deck" && to == "table") {
                    if (gamedata['cards'].length > 0) {
                        while(true) { // loop until a valid card drawn
                            if (gamedata['cards'][0] == "RESHUFFLE") {
                                reshuffle();
                            }
                            else { // only add to hand if not a reshuffle card
                                card = gamedata['cards'].shift();
                                table.push(card);
                                break;
                            }
                        }
                    }
                }

                else if (from == "hand" && to == "table") {
                    var index = hand.indexOf(card);
                    if (index > -1) {
                        hand.splice(index, 1);
                        table.push(card);
                        updateHand();
                        updateTable();
                    }
                    else {
                        updateHint("Hint: you can only play a card from your hand");
                    }
                }
            }
        }

        function cardType(card) {
            return card.substring(0, card.indexOf(":")).toLowerCase();
        }

        function cardDesc(card) {
            return card.substring(card.indexOf(":")+2, card.indexOf("(")-1);
        }

        function cardValue(card) {
            var num = 0;
            if (card) {
                num = parseInt(card.substring(card.lastIndexOf("(")+1,card.lastIndexOf(")")));
            }

            return num;
        }

        function onlyReshuffleCardsRemain() {
            var check = true;

            if (gamedata['cards'].length == 0) {
                check = false;
            }
            else {

                for (var i = 0; i < gamedata['cards'].length; i++) {
                    if (gamedata['cards'][i] != "RESHUFFLE") {
                        check = false;
                        break;
                    }
                }
            }

            return check;
        }

        function hasLowerResource() {
            var check = false;

            for (var i = 0; i < resources.length; i++) {
                if (cardValue(resources[i]) < cardValue(antagCard)) {
                    check = true;
                    break;
                }
            }

            return check;
        }

        function play() {
            phase = "play";
            roundnumber++;
            updateHint("[round " + roundnumber + "]");

            // finalize resources that player can use
            // (antagonist resource still remain on table)
            if (pfacet) {
                resources.push(pfacet);
            }
            if (bfacet) {
                resources.push(bfacet);
            }
            if (pbshared) {
                resources.push(pbshared);
            }

            // put non-resource cards back into deck

            if (protagonist) {
                table.push(protagonist);
            }
            if (beloved) {
                table.push(beloved);
            }
            if (antagonist) {
                table.push(antagonist);
            }
            gamedata['cards'] = gamedata['cards'].concat(table);
            table = new Array();
            updateTable();

            // add RESHUFFLE cards
            for (var i = 0; i < num_of_reshuffle_cards; i++) {
                gamedata['cards'].push("RESHUFFLE");
            }
            // shuffle deck
            gamedata['cards'] = shuffle(gamedata['cards']);

            // then draw a hand of 5 cards
            for (var i = 0; i < 5; i++) {
                moveCard("", "deck", "hand");
            }

            // remove setup listener
            var x = document.getElementById("gameArea");
            x.removeEventListener("click", setupListener);

            // add game time listener

            if (x.addEventListener) {
                // For all major browsers, except IE 8 and earlier
                x.addEventListener("click", gameOverListener);
            } else if (x.attachEvent) {
                // For IE 8 and earlier versions
                x.attachEvent("onclick", gameOverListener);
            }

            // update other parts of UI
            document.getElementById("finishsetup").style.display = "none";
            document.getElementById("table").style.height = "150px";
            document.getElementById("discard").style.display = "inline-block";
            document.getElementById("hand").style.display = "inline-block";
            updateDeck();
            updateDiscard();
            updateProtagonist();
            updateBeloved();
            updateAntagonist();
            enablePlayerTurnButtons();
            updateHint("Hint: with 5 cards in hand, you can choose the above options");
        }

        function end() {
            // remove setup listener
            var x = document.getElementById("gameArea");
            x.removeEventListener("click", gameOverListener);

            enablePlayerTurnButtons(false);
            enablePlayerResponseButtons(false);
            document.getElementById("gameover").style.display = "inline";
            phase = "";
            focus = "";
        }

        function waitAndSee() {
            protagMove = "wait";
            moveCard("","deck","hand");
            updateHint("{wait and see} draw 1 card into hand");
            antagMove();
            responseTurnSetup();
        }

        function pursueGoal() {
            var hint = "{pursue goal} select a card to play before antagonist responds; lower card wins";
            protagMove = "pursue";
            setFocus("pursue");
            updateHint(hint);
        }

        function sacrificeResource() {
            var hint = "{sacrifice resource} select a resource to sacrifice that doesn't belong to the antagonist";
            protagMove = "sacrifice";
            setFocus("sacrifice");
            updateHint(hint);
        }

        function reverseCondition() {
            var hint = "{reverse condition} select a card to play before antagonist responds; lower card wins";
            protagMove = "reverse";
            setFocus("reverse");
            updateHint(hint);
        }

        function attackAntagonist() {
            var hint = "{attack antagonist} select a card from your hand, then a resource that belongs to the antagonist; higher card wins";
            protagMove = "attack";
            setFocus("attack");
            updateHint(hint);
        }

        function playFromDeck() {
            if (protagCard == "") { // get new card if invalidated
                moveCard("", "deck", "table");
                protagCard = table[table.length - 1];
                protagCardValue = cardValue(protagCard);
            }

            if (protagMove == "wait") {
                // higher card wins

                if (protagCardValue > antagCardValue) {
                    updateHint("{play from deck} your " + protagCard + " beats " + antagCard + "; antagonist responds");

                    // antagonist will respond
                    antagMove();

                    if (protagCardValue > antagCardValue) {
                        // round over
                        updateHint("{after wait-and-see} your " + protagCard + " beats " + antagCard + "; round " + roundnumber + " ends");
                        newRound();
                    }
                    else {
                        updateHint("{after wait-and-see} your " + protagCard + " does not beat " + antagCard + "; how do you respond?");
                        protagCard = "";
                    }
                }
                else {
                    conditions++;
                    updateProtagonist();
                    updateHint("{play from deck} your " + protagCard + " did not beat " + antagCard + "; gain a condition; round " + roundnumber + " ends");
                    newRound();
                }
            }
            else if (protagMove == "pursue") {
                // lower card wins
                if (protagCardValue < antagCardValue) {
                    updateHint("{play from deck} your " + protagCard + " beats " + antagCard + "; antagonist responds");

                    // antagonist will respond
                    antagMove();

                    if (protagCardValue < antagCardValue) {
                        // round over
                        updateHint("{after pursue goal} your " + protagCard + " beats " + antagCard + "; gain progress; round " + roundnumber + " ends");
                        goalProgress++;
                        updateProtagonist();
                        newRound();
                    }
                    else {
                        updateHint("{after pursue goal} your " + protagCard + " does not beat " + antagCard + "; how do you respond?");
                        protagCard = "";
                    }
                }
                else {
                    conditions++;
                    updateProtagonist();
                    updateHint("{play from deck} your " + protagCard + " did not beat " + antagCard + "; gain a condition; round " + roundnumber + " ends");
                    newRound();
                }
            }

            else if (protagMove == "reverse") {
                // lower card wins
                if (protagCardValue < antagCardValue) {
                    updateHint("{play from deck} your " + protagCard + " beats " + antagCard + "; antagonist responds");

                    // antagonist will respond
                    antagMove();

                    if (protagCardValue < antagCardValue) {
                        // round over
                        updateHint("{after reverse condition} your " + protagCard + " beats " + antagCard + "; reverse one condition narratively but not mechanically; round " + roundnumber + " ends");
                        newRound();
                    }
                    else {
                        updateHint("{after reverse condition} your " + protagCard + " does not beat " + antagCard + "; how do you respond?");
                        protagCard = "";
                    }
                }
                else {
                    conditions++;
                    updateProtagonist();
                    updateHint("{play from deck} your " + protagCard + " did not beat " + antagCard + "; gain a condition; round " + roundnumber + " ends");
                    newRound();
                }
            }

            else if (protagMove == "sacrifice") {
                // lower card wins
                if (protagCardValue < antagCardValue) {
                    updateHint("{play from deck} your " + protagCard + " beats " + antagCard + "; antagonist responds");
                    // antagonist will respond
                    antagMove();

                    if (protagCardValue < antagCardValue) {
                        // round over
                        updateHint("{after sacrifice} your " + protagCard + " beats " + antagCard + "; round " + roundnumber + " ends");
                        newRound();
                    }
                    else {
                        updateHint("{after sacrifice} your " + protagCard + " does not beat " + antagCard + "; how do you respond?");
                        protagCard = "";
                    }
                }
                else {
                    conditions++;
                    updateProtagonist();
                    updateHint("{play from deck} your " + protagCard + " did not beat " + antagCard + "; gain a condition; round " + roundnumber + " ends");
                    newRound();
                }
            }
            else if (protagMove == "attack") {
                // higher card wins
                if (protagCardValue > antagCardValue) {
                    // remove the targeted resource card,
                    // from play, and the other 2 resources
                    // becomes usable by the player
                    if (afacet == antagCard) {
                        afacet = "";
                        updateAFacet();
                        resources.push(apshared);
                        resources.push(abshared);
                    }
                    else if (apshared == antagCard) {
                        apshared = "";
                        updateAPShared();
                        resources.push(afacet);
                        resources.push(abshared);
                    }
                    else if (abshared == antagCard) {
                        abshared = "";
                        updateABShared();
                        resources.push(afacet);
                        resources.push(apshared);
                    }
                    attackCardPicked = false;
                    targetCardPicked = false;
                    antagAttacked = true;

                    updateHint("{play from deck} your " + protagCard + " beats " + antagCard + "; antagonist responds");
                    // antagonist will respond
                    antagMove();

                    if (protagCardValue > antagCardValue) {
                        // round over
                        updateHint("{after attack} your " + protagCard + " beats " + antagCard + "; round " + roundnumber + " ends");
                        newRound();
                    }
                    else {
                        updateHint("{after attack} your " + protagCard + " does not beat " + antagCard + "; how do you respond?");
                        protagCard = "";
                    }

                }
                else {
                    attackCardPicked = false;
                    targetCardPicked = false;
                    conditions++;
                    updateProtagonist();
                    updateHint("{play from deck} your " + protagCard + " did not beat " + antagCard + "; gain a condition; round " + roundnumber + " ends");
                    newRound();
                }
            }
        }

        function giveIn() {
            // gain a condition, but also draw a card
            conditions++;
            updateProtagonist();
            moveCard("","deck","hand");
            updateHint("{give in} gain a condition and draw 1 card into hand; round " + roundnumber + " ends");
            newRound();
        }

        function newRound() {
            enablePlayerResponseButtons(false);
            enablePlayerTurnButtons();
            // clear table
            discard = discard.concat(table);
            table = new Array();
            updateTable();
            updateDiscard();
            focus = "";
            protagMove = "";
            protagCard = "";
            antagCard = "";

            if (conditions < conditionMax && goalProgress < goalMax) {
                // keep counting rounds unless game over
                roundnumber++;
                updateHint("[round " + roundnumber + "]");
            }
        }

        function responseTurnSetup() {
            enablePlayerTurnButtons(false);
            enablePlayerResponseButtons();
        }

        function antagMove() {
            var hint = "";

            moveCard("","deck","discard");
            antagCard = discard[discard.length - 1];
            antagCardValue = cardValue(antagCard);
            hint = "{antagonist's move} " + antagCard;

            if (protagMove == "wait" || protagMove == "attack") {
                hint += "; higher card wins; play from hand or use another option";
            }
            else if (protagMove == "pursue" || protagMove == "reverse" ||
                     protagMove == "sacrifice") {
                hint += "; lower card wins; play from hand or use another option";
            }

            updateHint(hint);
        }

        ////// EVENT LISTENERS /////////////

        function setupListener() {
            //if all needed elements are decided, offer
            //option to finish setup
            if (protagonist != "" && beloved != "" && antagonist != "" &&
                pfacet != "" && bfacet != "" && pbshared != "" &&
                afacet != "" && apshared != "" && abshared != "") {

                document.getElementById("finishsetup").style.display = "inline";
            }
            else { // otherwise hide that option
                document.getElementById("finishsetup").style.display = "none";
            }
        }

        function gameOverListener() {
            var hint_victory = "VICTORY! Use remaining cards in hand to write an epilogue?";
            var hint_defeat = "DEFEATED! Use remaining cards in hand to write an epilogue?";

            if (conditions >= conditionMax) {
                updateHint(hint_defeat);
                end();
            }
            else if (goalProgress >= goalMax) {
                updateHint(hint_victory);
                end();
            }

            if (onlyReshuffleCardsRemain()) {
                updateHint("note: the only cards left in the deck are \"Reshuffle\" cards, game cannot continue");
                end();
            }
        }

        // if user paste in a custom list of cards
        // reset the game with the new cards instead
        function inputDeck(deck) {
            gamedata['cards'] = {};
            var lines = deck.split('\n');
            var str = "";
            var passCheck = true;

            if (lines.length > 0 && lines[0]) {

                for (var i = 0; i < lines.length; i++) {
                    // check if the card format is correct
                    lines[i] = lines[i].trim();
                    if (!cardFormatOK(lines[i])) {
                      passCheck = false;
                      break;
                    }
                    // reformat card text to make it wrap
                    str = lines[i];
                    lines[i] = cardType(str) + ": " +
                              str.substring(str.indexOf(":")+1).trim();
                }
            }
            else {
                passCheck = false;
            }

            if (passCheck) {
                gamedata['cards'] = lines;
                newSetup();
                updateTable();
            }
            else {
                alert("Please double-check if all cards are formatted correctly.");
            }
            $('#deckbox').hide();
        }

        function cardFormatOK(card) {
            var c = cardType(card);
            var result = false;

            if (c == "character" || c == "event" ||
                c == "item" || c == "place" ||
                c == "aspect" || c == "detail") {
                result = true;
            }
            return result;
        }
    </script>
</body>
</html>
